import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
from itertools import combinations
from scipy.spatial import ConvexHull
from mpl_toolkits.mplot3d.art3d import Poly3DCollection

def initialize_3d_plot(title="3D Plot", labels=("X Axis", "Y Axis", "Z Axis"), view=(30, 45)):
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.set_title(title)
    ax.set_xlabel(labels[0])
    ax.set_ylabel(labels[1])
    ax.set_zlabel(labels[2])
    ax.view_init(elev=view[0], azim=view[1])
    return fig, ax

def set_axes_equal(ax):
    """Set equal aspect ratio for a 3D plot."""
    # Get limits for each axis
    x_limits = ax.get_xlim3d()
    y_limits = ax.get_ylim3d()
    z_limits = ax.get_zlim3d()

    # Calculate the spans and midpoints
    x_range = (x_limits[1] - x_limits[0]) / 2
    y_range = (y_limits[1] - y_limits[0]) / 2
    z_range = (z_limits[1] - z_limits[0]) / 2
    x_mid = np.mean(x_limits)
    y_mid = np.mean(y_limits)
    z_mid = np.mean(z_limits)

    # Set equal limits
    max_range = max(x_range, y_range, z_range)
    ax.set_xlim3d([x_mid - max_range, x_mid + max_range])
    ax.set_ylim3d([y_mid - max_range, y_mid + max_range])
    ax.set_zlim3d([z_mid - max_range, z_mid + max_range])

    # Adjust grid display
    ax.set_box_aspect([1, 1, 1])


def visualize_shape(shape_func=None, shape_type='surface', **kwargs):
    """Visualize a shape generated by a given shape function."""
    fig, ax = initialize_3d_plot(title=kwargs.get("title", "3D Shape"), view=kwargs.get("view", (30, 45)))

    # Call the shape function
    output = shape_func(**kwargs)

    if len(output) == 3 and shape_type == "surface":
        # Smooth surface: x, y, z arrays
        x, y, z = output
        ax.plot_surface(x, y, z, color = kwargs.get("color", "cyan"), alpha=kwargs.get("alpha", 0.8), edgecolor="none")

    elif len(output) == 3 and shape_type == "scatter":
        # Polyhedral shape: vertices, faces, and edges
        vertices, faces, edges = output
        poly3d = [[vertices[idx] for idx in face] for face in faces]
        collection = Poly3DCollection(poly3d, alpha=kwargs.get("alpha", 0.6), facecolors=kwargs.get("facecolor", "cyan"))
        ax.add_collection3d(collection)
        ax.scatter(vertices[:, 0], vertices[:, 1], vertices[:, 2], color="red", s=20)  # Optional: Plot vertices
        for edge in edges:
            ax.plot3D(*zip(*vertices[edge]), color="blue")
    
    elif shape_type == "incomplete_surface" and len(output) == 5:
        # Incomplete surface: x, y, z arrays + caps (cap1 and cap2)
        x, y, z, cap1, cap2 = output
        ax.plot_surface(x, y, z, color=kwargs.get("color", "cyan"), alpha=kwargs.get("alpha", 0.8), edgecolor="None")

        # Add caps to close the shape
        for cap in [cap1, cap2]:
            poly = Poly3DCollection([cap], alpha=kwargs.get("alpha", 0.6), color=kwargs.get("cap_color", "cyan"))
            ax.add_collection3d(poly)
    else:
        raise ValueError("Shape function must return valid data for the specified shape type.")


    set_axes_equal(ax)  # Ensure equal aspect ratio
    plt.tight_layout()


    ax.set_xticklabels([])
    ax.set_yticklabels([])
    ax.set_zticklabels([])
    

    if kwargs.get("filename", None):
        fig.savefig("math_plots/" + kwargs["filename"], dpi=300)
    if kwargs.get("plot", True):
        plt.show()
    else:
        plt.close()

def generate_cube(length=1, **kwargs):
    """Generate vertices, faces, and edges for a cube."""
    vertices = np.array([
        [0, 0, 0], [length, 0, 0], [length, length, 0], [0, length, 0],  # Bottom
        [0, 0, length], [length, 0, length], [length, length, length], [0, length, length]  # Top
    ])
    faces = [
        [0, 1, 2, 3],  # Bottom
        [4, 5, 6, 7],  # Top
        [0, 1, 5, 4],  # Front
        [2, 3, 7, 6],  # Back
        [1, 2, 6, 5],  # Right
        [0, 3, 7, 4],  # Left
    ]
    edges = [
        [0, 1], [1, 2], [2, 3], [3, 0],  # Bottom edges
        [4, 5], [5, 6], [6, 7], [7, 4],  # Top edges
        [0, 4], [1, 5], [2, 6], [3, 7]   # Vertical edges
    ]
    return vertices, faces, edges

def generate_icosahedron(radius=1, **kwargs):
    """Generate vertices, faces, and edges for an icosahedron."""
    t = (1 + np.sqrt(5)) / 2  # Golden ratio
    vertices = np.array([
        [-1, t, 0], [1, t, 0], [-1, -t, 0], [1, -t, 0],
        [0, -1, t], [0, 1, t], [0, -1, -t], [0, 1, -t],
        [t, 0, -1], [t, 0, 1], [-t, 0, -1], [-t, 0, 1]
    ])
    vertices /= np.linalg.norm(vertices, axis=1).max()  # Normalize vertices
    vertices *= radius

    hull = ConvexHull(vertices)
    faces = hull.simplices  # Triangular faces

    edges = set()
    for face in faces:
        for i, j in combinations(face, 2):
            edges.add(tuple(sorted((i, j))))
    edges = np.array(list(edges))

    return vertices, faces, edges

def generate_hebesphenorotunda(radius=1, **kwargs):
    """Generate vertices, faces, and edges for the triangular hebesphenorotunda."""
    t = (1 + np.sqrt(5)) / 2  # Golden ratio
    a = radius
    b = radius / t  # Smaller side of the golden ratio
    c = radius * (t - 1)  # Intermediate derived constant

    # Corrected vertices of the hebesphenorotunda
    vertices = np.array([
        [0, 0, a * 2],  # Top vertex
        [a, b, a], [-a, b, a], [0, -c, a],  # Top pentagon
        [c, -a, 0], [-c, -a, 0], [-b, 0, -a], [b, 0, -a],  # Lower belt
        [0, c, 0],  # Connecting triangle vertex
        [b, c, -a], [-b, c, -a],  # Bottom edge vertices
        [0, 0, -a * 2],  # Bottom tip
    ])

    # Corrected faces of the hebesphenorotunda
    faces = [
        [0, 1, 2], [0, 2, 3], [0, 3, 1],  # Top triangles
        [1, 2, 8], [2, 3, 8], [3, 1, 8],  # Middle triangles
        [1, 4, 8], [2, 5, 8], [3, 6, 8],  # Connecting pentagon to triangles
        [4, 5, 6, 7],  # Quadrilateral belt
        [4, 7, 9], [7, 9, 10], [9, 10, 11],  # Bottom triangles
        [5, 6, 11, 10],  # Bottom quadrilateral
    ]

    # Generate edges from faces
    edges = set()
    for face in faces:
        for i in range(len(face)):
            edge = tuple(sorted((face[i], face[(i + 1) % len(face)])))
            edges.add(edge)

    edges = np.array(list(edges))

    return vertices, faces, edges

def generate_heart_shape(**kwargs):
    """Generate x, y, z coordinates for a 3D heart shape."""
    u = np.linspace(0, np.pi, 100)
    v = np.linspace(0, 2 * np.pi, 100)
    u_grid, v_grid = np.meshgrid(u, v)

    x = 16 * np.sin(u_grid)**3 * np.sin(v_grid)
    y = (13 * np.cos(u_grid) - 5 * np.cos(2 * u_grid) - 2 * np.cos(3 * u_grid) - np.cos(4 * u_grid)) * np.sin(v_grid)
    z = (13 * np.cos(u_grid) - 5 * np.cos(2 * u_grid) - 2 * np.cos(3 * u_grid) - np.cos(4 * u_grid)) * np.cos(v_grid)

    return x, y, z

def generate_wave_surface(**kwargs):
    x = np.linspace(-1, 1, 500)
    y = np.linspace(-1, 1, 500)
    X, Y = np.meshgrid(x, y)
    Z = X**2 + Y**2 - 1
    return X, Y, Z

def generate_sphere(radius=1, **kwargs):
    phi = np.linspace(0, 2* np.pi, 100)
    theta = np.linspace(0, np.pi, 100)
    x = radius * np.outer(np.cos(phi), np.sin(theta))
    y = radius * np.outer(np.sin(phi), np.sin(theta))
    z = radius * np.outer(np.ones(np.size(phi)), np.cos(theta))
    return x, y, z

def generate_cylinder(radius=1, height=4, **kwargs):
    # Generate cylinder surface
    phi = np.linspace(0, 2 * np.pi, 100)  
    z = np.linspace(0, height, 100)       
    phi_grid, z_grid = np.meshgrid(phi, z)

    x = radius * np.cos(phi_grid)
    y = radius * np.sin(phi_grid)

    # Top and bottom caps
    phi_circle = np.linspace(0, 2 * np.pi, 100)
    x_top = radius * np.cos(phi_circle)
    y_top = radius * np.sin(phi_circle)
    z_top = np.full_like(phi_circle, height)

    x_bottom = radius * np.cos(phi_circle)
    y_bottom = radius * np.sin(phi_circle)
    z_bottom = np.zeros_like(phi_circle)

    cap_top = np.column_stack((x_top, y_top, z_top))
    cap_bottom = np.column_stack((x_bottom, y_bottom, z_bottom))

    return x, y, z_grid, cap_top, cap_bottom

def generate_torus(major_radius=3, minor_radius=1, **kwargs):
    u = np.linspace(0, 2 * np.pi, 100)
    v = np.linspace(0, 2 * np.pi, 100)
    u_grid, v_grid = np.meshgrid(u, v)
    x = (major_radius + minor_radius * np.cos(v_grid)) * np.cos(u_grid)
    y = (major_radius + minor_radius * np.cos(v_grid)) * np.sin(u_grid)
    z = minor_radius * np.sin(v_grid)
    return x, y, z

def generate_incomplete_sphere(radius=1, phi_range=(-0.1*np.pi, -0 * np.pi), theta_range=(0, np.pi), **kwargs):
    """Generate vertices and faces for an incomplete sphere."""
    phi = np.linspace(phi_range[0], phi_range[1], 50)
    theta = np.linspace(theta_range[0], theta_range[1], 50)
    phi_grid, theta_grid = np.meshgrid(phi, theta)

    # Generate x, y, z coordinates for the surface
    x = radius * np.outer(np.sin(theta), np.cos(phi))
    y = radius * np.outer(np.sin(theta), np.sin(phi))
    z = radius * np.outer(np.cos(theta), np.ones_like(phi))

    cap1 = np.array([
        [radius * np.sin(t) * np.cos(phi_range[0]), 
         radius * np.sin(t) * np.sin(phi_range[0]), 
         radius * np.cos(t)]
        for t in theta
    ])
    cap2 = np.array([
        [radius * np.sin(t) * np.cos(phi_range[1]), 
         radius * np.sin(t) * np.sin(phi_range[1]), 
         radius * np.cos(t)]
        for t in theta
    ])

    return x, y, z, cap1, cap2

visualize_shape(generate_cube, 'scatter', length=2, title="Filled Cube", filename="cube.png", plot=False)
visualize_shape(generate_icosahedron, 'scatter', length=2, title="Filled Icosahedron", filename="icosohedron.png", plot=False)
visualize_shape(generate_sphere, 'surface', title="Sphere", filename="sphere.png", plot=False)
visualize_shape(generate_torus, 'surface', title="Torus", filename="torus.png", plot=False)
visualize_shape(generate_incomplete_sphere, 'incomplete_surface', title="Sphere", filename="sphere_2.png", plot=False)
visualize_shape(generate_cylinder, 'incomplete_surface', title="cylinder", filename="cylinder.png", plot=False)
